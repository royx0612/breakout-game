<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰“ç£šå¡ŠéŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#e94560',
                        secondary: '#c73659',
                        dark: '#1a1a2e',
                        darker: '#0f3460',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            touch-action: none;
        }
        .glow {
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.3), 
                        inset 0 0 50px rgba(0, 0, 0, 0.5);
        }
        .text-glow {
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        .btn-glow:hover {
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.7);
        }
        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }
        .animate-popup {
            animation: fadeInScale 0.3s ease forwards;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-dark via-[#16213e] to-darker min-h-screen flex flex-col items-center justify-center p-2 sm:p-4">
    
    <div id="gameContainer" class="w-full max-w-4xl flex flex-col items-center">
        <!-- æ¨™é¡Œ -->
        <h1 class="text-2xl sm:text-4xl font-bold text-primary text-glow mb-2 sm:mb-4">ğŸ® æ‰“ç£šå¡ŠéŠæˆ²</h1>
        
        <!-- è¨ˆåˆ†æ¿ -->
        <div class="flex justify-center gap-2 sm:gap-8 mb-2 sm:mb-4 text-white text-xs sm:text-lg">
            <span class="bg-white/10 px-3 py-1 sm:px-5 sm:py-2 rounded-full backdrop-blur">
                åˆ†æ•¸: <strong id="score">0</strong>
            </span>
            <span class="bg-white/10 px-3 py-1 sm:px-5 sm:py-2 rounded-full backdrop-blur">
                ç”Ÿå‘½: <strong id="lives">3</strong>
            </span>
            <span class="bg-white/10 px-3 py-1 sm:px-5 sm:py-2 rounded-full backdrop-blur">
                é—œå¡: <strong id="level">1</strong>
            </span>
        </div>
        
        <!-- éŠæˆ²ç•«å¸ƒ -->
        <canvas id="gameCanvas" class="rounded-lg sm:rounded-xl glow bg-gradient-to-b from-[#0a0a1a] to-[#1a1a3a]"></canvas>
        
        <!-- èªªæ˜æ–‡å­— - æ¡Œé¢ç‰ˆ -->
        <div class="hidden sm:block text-gray-400 mt-4 text-sm">
            <kbd class="bg-gray-700 px-2 py-1 rounded border border-gray-600">â† â†’</kbd> æˆ– 
            <kbd class="bg-gray-700 px-2 py-1 rounded border border-gray-600">æ»‘é¼ </kbd> ç§»å‹•æ“‹æ¿ | 
            <kbd class="bg-gray-700 px-2 py-1 rounded border border-gray-600">ç©ºç™½éµ</kbd> ç™¼å°„çƒ | 
            <kbd class="bg-gray-700 px-2 py-1 rounded border border-gray-600">P</kbd> æš«åœ
        </div>
        
        <!-- èªªæ˜æ–‡å­— - æ‰‹æ©Ÿç‰ˆ -->
        <div class="sm:hidden text-gray-400 mt-2 text-xs text-center">
            ğŸ‘† æ»‘å‹•æ§åˆ¶æ“‹æ¿ | é»æ“Šç™¼å°„çƒ
        </div>

        <!-- è™›æ“¬æ§åˆ¶æŒ‰éˆ• - æ‰‹æ©Ÿç‰ˆ -->
        <div id="mobileControls" class="sm:hidden flex justify-center gap-4 mt-3 w-full max-w-xs">
            <button id="btnLeft" class="flex-1 bg-primary/80 text-white py-4 rounded-xl text-2xl active:bg-primary active:scale-95 transition-all">
                â—€
            </button>
            <button id="btnLaunch" class="flex-1 bg-green-500/80 text-white py-4 rounded-xl text-lg active:bg-green-500 active:scale-95 transition-all">
                ç™¼å°„
            </button>
            <button id="btnRight" class="flex-1 bg-primary/80 text-white py-4 rounded-xl text-2xl active:bg-primary active:scale-95 transition-all">
                â–¶
            </button>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ Overlay -->
    <div id="startOverlay" class="fixed inset-0 bg-black/70 backdrop-blur flex items-center justify-center z-50">
        <div class="bg-black/95 p-6 sm:p-10 rounded-2xl text-center text-white border-2 border-primary animate-popup mx-4">
            <h2 class="text-2xl sm:text-3xl font-bold text-primary mb-4 sm:mb-6">ğŸ¯ æ‰“ç£šå¡ŠéŠæˆ²</h2>
            <p class="mb-2 text-sm sm:text-base">ä½¿ç”¨æ»‘é¼ æˆ–æ‰‹æŒ‡æ§åˆ¶æ“‹æ¿</p>
            <p class="mb-4 sm:mb-6 text-sm sm:text-base">æ“Šç ´æ‰€æœ‰ç£šå¡Šå³å¯éé—œï¼</p>
            <button onclick="startGame()" class="bg-gradient-to-r from-primary to-secondary text-white px-8 sm:px-10 py-3 sm:py-4 text-lg sm:text-xl rounded-full btn-glow transition-all hover:scale-105">
                é–‹å§‹éŠæˆ²
            </button>
        </div>
    </div>

    <!-- éŠæˆ²çµæŸ Overlay -->
    <div id="gameOverOverlay" class="fixed inset-0 bg-black/70 backdrop-blur hidden items-center justify-center z-50">
        <div class="bg-black/95 p-6 sm:p-10 rounded-2xl text-center text-white border-2 border-primary animate-popup mx-4">
            <h2 class="text-2xl sm:text-3xl font-bold text-primary mb-4">ğŸ’” éŠæˆ²çµæŸ</h2>
            <p class="mb-2">ä½ çš„æœ€çµ‚åˆ†æ•¸:</p>
            <div class="text-4xl sm:text-5xl text-yellow-400 my-4 sm:my-6" id="finalScore">0</div>
            <button onclick="restartGame()" class="bg-gradient-to-r from-primary to-secondary text-white px-8 sm:px-10 py-3 sm:py-4 text-lg sm:text-xl rounded-full btn-glow transition-all hover:scale-105">
                å†ç©ä¸€æ¬¡
            </button>
        </div>
    </div>

    <!-- ç²å‹ Overlay -->
    <div id="winOverlay" class="fixed inset-0 bg-black/70 backdrop-blur hidden items-center justify-center z-50">
        <div class="bg-black/95 p-6 sm:p-10 rounded-2xl text-center text-white border-2 border-primary animate-popup mx-4">
            <h2 class="text-2xl sm:text-3xl font-bold text-primary mb-4">ğŸ‰ æ­å–œéé—œï¼</h2>
            <p class="mb-2">ä½ å®Œæˆäº†æ‰€æœ‰é—œå¡ï¼</p>
            <div class="text-4xl sm:text-5xl text-yellow-400 my-4 sm:my-6" id="winScore">0</div>
            <button onclick="restartGame()" class="bg-gradient-to-r from-primary to-secondary text-white px-8 sm:px-10 py-3 sm:py-4 text-lg sm:text-xl rounded-full btn-glow transition-all hover:scale-105">
                å†ç©ä¸€æ¬¡
            </button>
        </div>
    </div>

    <!-- æ‰è½æç¤º Overlay -->
    <div id="fallOverlay" class="fixed inset-0 bg-black/70 backdrop-blur hidden items-center justify-center z-50">
        <div class="bg-black/95 p-6 sm:p-10 rounded-2xl text-center text-white border-2 border-red-400 animate-popup mx-4" style="box-shadow: 0 0 60px rgba(255, 107, 107, 0.6);">
            <h2 class="text-2xl sm:text-3xl font-bold text-red-400 mb-4">ğŸ˜µ ä½ å·²ç¶“æ‰ä¸‹å»äº†ï¼</h2>
            <div class="text-3xl sm:text-4xl my-4" id="heartsDisplay">â¤ï¸ â¤ï¸ ğŸ–¤</div>
            <p class="mb-4 sm:mb-6 text-lg">å‰©é¤˜ç”Ÿå‘½: <strong class="text-yellow-400 text-2xl" id="remainingLives">2</strong></p>
            <button onclick="continueGame()" class="bg-gradient-to-r from-red-500 to-red-600 text-white px-8 sm:px-10 py-3 sm:py-4 text-lg sm:text-xl rounded-full btn-glow transition-all hover:scale-105">
                ç¹¼çºŒæŒ‘æˆ°
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // éŸ¿æ‡‰å¼ç•«å¸ƒå¤§å°
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = Math.min(container.clientWidth - 16, 800);
            const isMobile = window.innerWidth < 640;
            
            if (isMobile) {
                canvas.width = maxWidth;
                canvas.height = Math.min(window.innerHeight * 0.55, 500);
            } else {
                canvas.width = maxWidth;
                canvas.height = Math.min(maxWidth * 0.75, 600);
            }
            
            // æ›´æ–°éŠæˆ²å…ƒç´ çš„ä½ç½®
            updateGameElements();
        }

        function updateGameElements() {
            paddle.width = canvas.width * 0.15;
            paddle.y = canvas.height - 30;
            paddle.x = Math.min(paddle.x, canvas.width - paddle.width);
            
            brickConfig.width = (canvas.width - brickConfig.offsetLeft * 2 - brickConfig.padding * (brickConfig.columnCount - 1)) / brickConfig.columnCount;
            brickConfig.height = Math.max(20, canvas.height * 0.04);
        }

        // éŠæˆ²ç‹€æ…‹
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        const maxLevel = 5;

        // çƒçš„å±¬æ€§
        const ball = {
            radius: 8,
            speed: 4,
            baseSpeed: 4,
        };

        // æ™‚é–“åŠ é€Ÿè¨­å®š
        let gameTime = 0;
        const SPEED_INCREASE_INTERVAL = 500;
        const SPEED_INCREASE_AMOUNT = 0.1;
        const MAX_SPEED_MULTIPLIER = 2.5;

        // æ“‹æ¿å±¬æ€§
        const paddle = {
            width: 120,
            height: 12,
            x: 0,
            y: 0,
            speed: 8,
            dx: 0
        };

        // ç£šå¡Šè¨­å®š
        const brickConfig = {
            rowCount: 5,
            columnCount: 8,
            width: 70,
            height: 22,
            padding: 4,
            offsetTop: 50,
            offsetLeft: 20
        };

        let bricks = [];
        let balls = [];
        let particles = [];
        let powerUps = [];
        let powerUpTexts = [];

        // é“å…·é¡å‹
        const POWERUP_TYPES = {
            MULTI_BALL: { color: '#ff6b6b', icon: 'âšª', name: 'ä¸‰é¡†çƒ' },
            WIDE_PADDLE: { color: '#1dd1a1', icon: 'â†”ï¸', name: 'æ“‹æ¿åŠ å¯¬' },
            SPEED_UP: { color: '#feca57', icon: 'âš¡', name: 'åŠ é€Ÿ' },
            SPEED_DOWN: { color: '#48dbfb', icon: 'ğŸ¢', name: 'æ¸›é€Ÿ' }
        };

        let activeEffects = {
            widePaddle: false,
            speedModifier: 1
        };

        const DEFAULT_PADDLE_WIDTH_RATIO = 0.15;

        // ç£šå¡Šé¡è‰²
        const brickColors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3'];

        // åˆå§‹åŒ–ç©ºç£šå¡Š
        function initEmptyBricks() {
            bricks = [];
            for (let c = 0; c < brickConfig.columnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    bricks[c][r] = { status: 0 };
                }
            }
        }

        // åˆå§‹åŒ–ç£šå¡Š
        function initBricks() {
            bricks = [];
            for (let c = 0; c < brickConfig.columnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    let hits = r < level - 1 ? 2 : 1;
                    if (level >= 4 && r === 0) hits = 3;
                    
                    let powerUp = null;
                    if (Math.random() < 0.15) {
                        const types = Object.keys(POWERUP_TYPES);
                        powerUp = types[Math.floor(Math.random() * types.length)];
                    }
                    
                    bricks[c][r] = {
                        x: 0, y: 0, status: 1,
                        hits: hits, maxHits: hits,
                        color: brickColors[r],
                        powerUp: powerUp
                    };
                }
            }
        }

        // å‰µå»ºç²’å­
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x, y,
                    dx: (Math.random() - 0.5) * 6,
                    dy: (Math.random() - 0.5) * 6,
                    radius: Math.random() * 3 + 1,
                    color, life: 1
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx; p.y += p.dy;
                p.life -= 0.03; p.radius *= 0.97;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // ç¹ªè£½çƒ
        function drawBall() {
            balls.forEach(b => {
                const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.radius * 2);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, '#e94560');
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // ç¹ªè£½æ“‹æ¿
        function drawPaddle() {
            ctx.shadowColor = '#e94560';
            ctx.shadowBlur = 15;
            
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#e94560');
            gradient.addColorStop(1, '#c73659');
            
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 6);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // ç¹ªè£½ç£šå¡Š
        function drawBricks() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status === 1) {
                        const brickX = c * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft;
                        const brickY = r * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop;
                        brick.x = brickX;
                        brick.y = brickY;

                        const alpha = 0.5 + (brick.hits / brick.maxHits) * 0.5;
                        
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, brickConfig.width, brickConfig.height, 4);
                        ctx.fillStyle = brick.color;
                        ctx.globalAlpha = alpha;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        ctx.fillStyle = '#fff';
                        ctx.font = `bold ${Math.max(10, brickConfig.height * 0.5)}px Arial`;
                        ctx.textAlign = 'center';
                        
                        if (brick.powerUp) {
                            ctx.font = `${Math.max(10, brickConfig.height * 0.6)}px Arial`;
                            ctx.fillText(POWERUP_TYPES[brick.powerUp].icon, brickX + brickConfig.width / 2, brickY + brickConfig.height / 2 + 4);
                        } else if (brick.hits > 1) {
                            ctx.fillText(brick.hits, brickX + brickConfig.width / 2, brickY + brickConfig.height / 2 + 4);
                        }
                    }
                }
            }
        }

        // ç¹ªè£½é“å…·
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.beginPath();
                ctx.roundRect(p.x - 12, p.y - 8, 24, 16, 4);
                ctx.fillStyle = POWERUP_TYPES[p.type].color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.font = '10px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(POWERUP_TYPES[p.type].icon, p.x, p.y + 3);
            });
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.y += 2.5;
                
                if (p.y + 8 >= paddle.y && p.y - 8 <= paddle.y + paddle.height &&
                    p.x >= paddle.x && p.x <= paddle.x + paddle.width) {
                    activatePowerUp(p.type);
                    powerUps.splice(i, 1);
                    continue;
                }
                
                if (p.y > canvas.height) powerUps.splice(i, 1);
            }
        }

        function activatePowerUp(type) {
            switch (type) {
                case 'MULTI_BALL':
                    const newBalls = [];
                    balls.forEach(b => {
                        if (b.launched) {
                            for (let angle of [-0.5, 0.5]) {
                                const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                                const currentAngle = Math.atan2(b.dy, b.dx);
                                newBalls.push({
                                    x: b.x, y: b.y, radius: b.radius,
                                    dx: speed * Math.cos(currentAngle + angle),
                                    dy: speed * Math.sin(currentAngle + angle),
                                    speed: b.speed, launched: true
                                });
                            }
                        }
                    });
                    balls = balls.concat(newBalls);
                    break;
                case 'WIDE_PADDLE':
                    if (!activeEffects.widePaddle) {
                        activeEffects.widePaddle = true;
                        paddle.width = canvas.width * DEFAULT_PADDLE_WIDTH_RATIO * 1.5;
                    }
                    break;
                case 'SPEED_UP':
                    activeEffects.speedModifier = 1.3;
                    balls.forEach(b => {
                        const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                        const angle = Math.atan2(b.dy, b.dx);
                        b.dx = speed * 1.15 * Math.cos(angle);
                        b.dy = speed * 1.15 * Math.sin(angle);
                    });
                    break;
                case 'SPEED_DOWN':
                    activeEffects.speedModifier = 0.7;
                    balls.forEach(b => {
                        const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                        const angle = Math.atan2(b.dy, b.dx);
                        b.dx = speed * 0.85 * Math.cos(angle);
                        b.dy = speed * 0.85 * Math.sin(angle);
                    });
                    break;
            }
            createPowerUpText(POWERUP_TYPES[type].name);
        }

        function createPowerUpText(text) {
            powerUpTexts.push({ text, y: canvas.height / 2, alpha: 1 });
        }

        function updatePowerUpTexts() {
            for (let i = powerUpTexts.length - 1; i >= 0; i--) {
                const t = powerUpTexts[i];
                t.y -= 1; t.alpha -= 0.02;
                if (t.alpha <= 0) powerUpTexts.splice(i, 1);
            }
        }

        function drawPowerUpTexts() {
            powerUpTexts.forEach(t => {
                ctx.font = `bold ${Math.max(16, canvas.width * 0.03)}px Arial`;
                ctx.fillStyle = `rgba(255, 255, 255, ${t.alpha})`;
                ctx.textAlign = 'center';
                ctx.fillText(t.text, canvas.width / 2, t.y);
            });
        }

        function resetEffects() {
            activeEffects.widePaddle = false;
            activeEffects.speedModifier = 1;
            paddle.width = canvas.width * DEFAULT_PADDLE_WIDTH_RATIO;
            powerUps = [];
        }

        // ç¢°æ’æª¢æ¸¬
        function collisionDetection() {
            balls.forEach(b => {
                if (!b.launched) return;
                
                for (let c = 0; c < brickConfig.columnCount; c++) {
                    for (let r = 0; r < brickConfig.rowCount; r++) {
                        const brick = bricks[c][r];
                        if (brick.status === 1) {
                            const closestX = Math.max(brick.x, Math.min(b.x, brick.x + brickConfig.width));
                            const closestY = Math.max(brick.y, Math.min(b.y, brick.y + brickConfig.height));
                            const distX = b.x - closestX;
                            const distY = b.y - closestY;
                            const distance = Math.sqrt(distX * distX + distY * distY);
                            
                            if (distance <= b.radius) {
                                const overlapX = (brickConfig.width / 2 + b.radius) - Math.abs(b.x - (brick.x + brickConfig.width / 2));
                                const overlapY = (brickConfig.height / 2 + b.radius) - Math.abs(b.y - (brick.y + brickConfig.height / 2));
                                
                                if (overlapX < overlapY) {
                                    b.dx = -b.dx;
                                    b.x += b.dx > 0 ? overlapX : -overlapX;
                                } else {
                                    b.dy = -b.dy;
                                    b.y += b.dy > 0 ? overlapY : -overlapY;
                                }
                                
                                brick.hits--;
                                
                                if (brick.hits <= 0) {
                                    brick.status = 0;
                                    score += 10 * level;
                                    createParticles(brick.x + brickConfig.width / 2, brick.y + brickConfig.height / 2, brick.color);
                                    
                                    if (brick.powerUp) {
                                        powerUps.push({
                                            x: brick.x + brickConfig.width / 2,
                                            y: brick.y + brickConfig.height / 2,
                                            type: brick.powerUp
                                        });
                                    }
                                }
                                
                                document.getElementById('score').textContent = score;
                                
                                if (checkWin()) {
                                    if (level < maxLevel) nextLevel();
                                    else showWinScreen();
                                }
                                return;
                            }
                        }
                    }
                }
            });
        }

        function checkWin() {
            for (let c = 0; c < brickConfig.columnCount; c++) {
                for (let r = 0; r < brickConfig.rowCount; r++) {
                    if (bricks[c][r].status === 1) return false;
                }
            }
            return true;
        }

        function nextLevel() {
            level++;
            document.getElementById('level').textContent = level;
            ball.baseSpeed += 0.2;
            ball.speed = ball.baseSpeed;
            resetBall();
            initBricks();
        }

        function resetBall() {
            const speed = ball.speed * (canvas.width / 800);
            balls = [{
                x: paddle.x + paddle.width / 2,
                y: paddle.y - ball.radius - 5,
                radius: Math.max(6, canvas.width * 0.012),
                dx: speed * (Math.random() > 0.5 ? 1 : -1),
                dy: -speed,
                speed: speed,
                launched: false
            }];
            resetEffects();
        }

        // æŒ‰éµç‹€æ…‹
        const keys = { left: false, right: false };

        // æ›´æ–°éŠæˆ²
        function update() {
            if (!gameRunning || gamePaused) return;

            gameTime++;
            if (gameTime % SPEED_INCREASE_INTERVAL === 0) {
                const currentMultiplier = ball.speed / ball.baseSpeed;
                if (currentMultiplier < MAX_SPEED_MULTIPLIER) {
                    ball.speed += SPEED_INCREASE_AMOUNT;
                    balls.forEach(b => {
                        const currentSpeed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                        const angle = Math.atan2(b.dy, b.dx);
                        const newSpeed = currentSpeed + SPEED_INCREASE_AMOUNT * (canvas.width / 800);
                        b.dx = newSpeed * Math.cos(angle);
                        b.dy = newSpeed * Math.sin(angle);
                        b.speed = newSpeed;
                    });
                }
            }

            if (keys.left && !keys.right) paddle.dx = -paddle.speed;
            else if (keys.right && !keys.left) paddle.dx = paddle.speed;
            else paddle.dx = 0;

            paddle.x += paddle.dx;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

            const unlaunchedBall = balls.find(b => !b.launched);
            if (unlaunchedBall) {
                unlaunchedBall.x = paddle.x + paddle.width / 2;
                unlaunchedBall.y = paddle.y - unlaunchedBall.radius - 5;
            }

            for (let i = balls.length - 1; i >= 0; i--) {
                const b = balls[i];
                if (!b.launched) continue;

                b.x += b.dx;
                b.y += b.dy;

                if (b.x - b.radius < 0) { b.x = b.radius; b.dx = Math.abs(b.dx); }
                else if (b.x + b.radius > canvas.width) { b.x = canvas.width - b.radius; b.dx = -Math.abs(b.dx); }
                if (b.y - b.radius < 0) { b.y = b.radius; b.dy = Math.abs(b.dy); }

                const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                if (Math.abs(b.dx) < 0.5) {
                    b.dx = (b.dx >= 0 ? 1 : -1) * speed * 0.3;
                    b.dy = (b.dy >= 0 ? 1 : -1) * Math.sqrt(speed * speed - b.dx * b.dx);
                }

                if (b.y + b.radius > paddle.y && b.y - b.radius < paddle.y + paddle.height &&
                    b.x > paddle.x && b.x < paddle.x + paddle.width && b.dy > 0) {
                    const hitPoint = (b.x - paddle.x) / paddle.width;
                    const angle = (hitPoint - 0.5) * Math.PI * 0.6;
                    b.dx = speed * Math.sin(angle);
                    b.dy = -Math.abs(speed * Math.cos(angle));
                    if (Math.abs(b.dx) < speed * 0.2) {
                        b.dx = (b.dx >= 0 ? 1 : -1) * speed * 0.2;
                        b.dy = -Math.sqrt(speed * speed - b.dx * b.dx);
                    }
                    b.y = paddle.y - b.radius - 1;
                }

                if (b.y + b.radius > canvas.height) balls.splice(i, 1);
            }

            if (balls.length === 0) {
                lives--;
                document.getElementById('lives').textContent = lives;
                if (lives <= 0) showGameOver();
                else showFallScreen();
            }

            collisionDetection();
            updateParticles();
            updatePowerUps();
            updatePowerUpTexts();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawPaddle();
            drawBall();
            drawParticles();
            drawPowerUps();
            drawPowerUpTexts();

            if (gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${canvas.width * 0.06}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('æš«åœä¸­', canvas.width / 2, canvas.height / 2);
                ctx.font = `${canvas.width * 0.03}px Arial`;
                ctx.fillText('æŒ‰ P ç¹¼çºŒ', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Overlay æ§åˆ¶
        function showOverlay(id) {
            const overlay = document.getElementById(id);
            overlay.style.display = 'flex';
        }

        function hideOverlay(id) {
            document.getElementById(id).style.display = 'none';
        }

        function startGame() {
            hideOverlay('startOverlay');
            gameRunning = true;
            score = 0; lives = 3; level = 1;
            gameTime = 0;
            ball.speed = ball.baseSpeed;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
            paddle.x = canvas.width / 2 - paddle.width / 2;
            initBricks();
            resetBall();
        }

        function restartGame() {
            hideOverlay('gameOverOverlay');
            hideOverlay('winOverlay');
            startGame();
        }

        function showGameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            showOverlay('gameOverOverlay');
        }

        function showWinScreen() {
            gameRunning = false;
            document.getElementById('winScore').textContent = score;
            showOverlay('winOverlay');
        }

        function showFallScreen() {
            gameRunning = false;
            document.getElementById('remainingLives').textContent = lives;
            let hearts = '';
            for (let i = 0; i < 3; i++) hearts += i < lives ? 'â¤ï¸ ' : 'ğŸ–¤ ';
            document.getElementById('heartsDisplay').textContent = hearts.trim();
            showOverlay('fallOverlay');
        }

        function continueGame() {
            hideOverlay('fallOverlay');
            gameRunning = true;
            resetBall();
        }

        function launchBalls() {
            balls.forEach(b => { if (!b.launched) b.launched = true; });
        }

        // éµç›¤æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            else if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            else if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                const fallOverlay = document.getElementById('fallOverlay');
                const startOverlay = document.getElementById('startOverlay');
                const gameOverOverlay = document.getElementById('gameOverOverlay');
                const winOverlay = document.getElementById('winOverlay');
                
                if (fallOverlay.style.display === 'flex') continueGame();
                else if (startOverlay.style.display === 'flex') startGame();
                else if (gameOverOverlay.style.display === 'flex') restartGame();
                else if (winOverlay.style.display === 'flex') restartGame();
                else if (gameRunning && !gamePaused) launchBalls();
            } else if (e.key === 'p' || e.key === 'P') {
                if (gameRunning) gamePaused = !gamePaused;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            else if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
        });

        // æ»‘é¼ æ§åˆ¶
        canvas.addEventListener('mousemove', (e) => {
            if (!gameRunning || gamePaused) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            paddle.x = mouseX - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
        });

        canvas.addEventListener('click', () => {
            if (gameRunning && !gamePaused) launchBalls();
        });

        // è§¸æ§æ§åˆ¶
        let touchStartX = 0;
        let lastTouchX = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning || gamePaused) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            lastTouchX = touchStartX;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameRunning || gamePaused) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            
            paddle.x = touchX - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            
            lastTouchX = touchX;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameRunning && !gamePaused) launchBalls();
        }, { passive: false });

        // è™›æ“¬æŒ‰éˆ•æ§åˆ¶
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const btnLaunch = document.getElementById('btnLaunch');

        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
        btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys.left = false; });
        btnLeft.addEventListener('mousedown', () => keys.left = true);
        btnLeft.addEventListener('mouseup', () => keys.left = false);
        btnLeft.addEventListener('mouseleave', () => keys.left = false);

        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
        btnRight.addEventListener('touchend', (e) => { e.preventDefault(); keys.right = false; });
        btnRight.addEventListener('mousedown', () => keys.right = true);
        btnRight.addEventListener('mouseup', () => keys.right = false);
        btnRight.addEventListener('mouseleave', () => keys.right = false);

        btnLaunch.addEventListener('touchstart', (e) => { e.preventDefault(); launchBalls(); });
        btnLaunch.addEventListener('click', () => launchBalls());

        // åˆå§‹åŒ–
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initEmptyBricks();
        paddle.x = canvas.width / 2 - paddle.width / 2;
        gameLoop();
    </script>
</body>
</html>
