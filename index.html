<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ‰“ç£šå¡ŠéŠæˆ²</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      .game-container {
        text-align: center;
      }

      h1 {
        color: #e94560;
        margin-bottom: 10px;
        text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        font-size: 2.5rem;
      }

      .score-board {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin-bottom: 15px;
        color: #fff;
        font-size: 1.2rem;
      }

      .score-board span {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 20px;
        border-radius: 20px;
        backdrop-filter: blur(5px);
      }

      canvas {
        background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 100%);
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(233, 69, 96, 0.3),
          inset 0 0 50px rgba(0, 0, 0, 0.5);
        cursor: none;
      }

      .instructions {
        color: #aaa;
        margin-top: 15px;
        font-size: 0.9rem;
      }

      .instructions kbd {
        background: #333;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid #555;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
        backdrop-filter: blur(5px);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .overlay.show {
        display: flex;
        opacity: 1;
      }

      #startOverlay {
        display: flex;
        opacity: 1;
      }

      #startScreen,
      #gameOverScreen,
      #winScreen,
      #fallScreen {
        background: rgba(0, 0, 0, 0.95);
        padding: 40px 60px;
        border-radius: 20px;
        text-align: center;
        color: white;
        border: 2px solid #e94560;
        box-shadow: 0 0 50px rgba(233, 69, 96, 0.5);
        transform: scale(1);
        transition: transform 0.3s ease, opacity 0.3s ease;
      }

      .overlay.show #startScreen,
      .overlay.show #gameOverScreen,
      .overlay.show #winScreen,
      .overlay.show #fallScreen {
        animation: fadeInScale 0.3s ease forwards;
      }

      @keyframes fadeInScale {
        0% {
          opacity: 0;
          transform: scale(0.9);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      #fallScreen {
        background: rgba(0, 0, 0, 0.95);
        border: 3px solid #ff6b6b;
        box-shadow: 0 0 60px rgba(255, 107, 107, 0.6),
          0 0 100px rgba(255, 107, 107, 0.3),
          inset 0 0 30px rgba(255, 107, 107, 0.1);
      }

      #fallScreen h2 {
        color: #ff6b6b;
        font-size: 2.2rem;
        text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
        margin-bottom: 25px;
      }

      #fallScreen p {
        font-size: 1.3rem;
        color: #fff;
      }

      #fallScreen #remainingLives {
        color: #ffd700;
        font-size: 2rem;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
      }

      #fallScreen .btn {
        background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
        margin-top: 25px;
      }

      #fallScreen .btn:hover {
        box-shadow: 0 0 25px rgba(255, 107, 107, 0.8);
      }

      .lives-icon {
        font-size: 2.5rem;
        margin: 15px 0;
      }

      .screen h2 {
        font-size: 2rem;
        margin-bottom: 20px;
        color: #e94560;
      }

      .screen p {
        margin-bottom: 15px;
        font-size: 1.1rem;
      }

      .btn {
        background: linear-gradient(135deg, #e94560, #c73659);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.2rem;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 10px;
      }

      .btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(233, 69, 96, 0.7);
      }

      .final-score {
        font-size: 2.5rem;
        color: #ffd700;
        margin: 20px 0;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>ğŸ® æ‰“ç£šå¡ŠéŠæˆ²</h1>
      <div class="score-board">
        <span>åˆ†æ•¸: <strong id="score">0</strong></span>
        <span>ç”Ÿå‘½: <strong id="lives">3</strong></span>
        <span>é—œå¡: <strong id="level">1</strong></span>
      </div>
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div class="instructions">
        <kbd>â† â†’</kbd> æˆ– <kbd>æ»‘é¼ </kbd> ç§»å‹•æ“‹æ¿ | <kbd>ç©ºç™½éµ</kbd> ç™¼å°„çƒ |
        <kbd>P</kbd> æš«åœ
      </div>

      <div id="startOverlay" class="overlay">
        <div id="startScreen" class="screen">
          <h2>ğŸ¯ æ‰“ç£šå¡ŠéŠæˆ²</h2>
          <p>ä½¿ç”¨æ»‘é¼ æˆ–æ–¹å‘éµæ§åˆ¶æ“‹æ¿</p>
          <p>æ“Šç ´æ‰€æœ‰ç£šå¡Šå³å¯éé—œï¼</p>
          <button class="btn" onclick="startGame()">é–‹å§‹éŠæˆ²</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay">
        <div id="gameOverScreen" class="screen">
          <h2>ğŸ’” éŠæˆ²çµæŸ</h2>
          <p>ä½ çš„æœ€çµ‚åˆ†æ•¸:</p>
          <div class="final-score" id="finalScore">0</div>
          <button class="btn" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
        </div>
      </div>

      <div id="winOverlay" class="overlay">
        <div id="winScreen" class="screen">
          <h2>ğŸ‰ æ­å–œéé—œï¼</h2>
          <p>ä½ å®Œæˆäº†æ‰€æœ‰é—œå¡ï¼</p>
          <div class="final-score" id="winScore">0</div>
          <button class="btn" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
        </div>
      </div>

      <div id="fallOverlay" class="overlay">
        <div id="fallScreen" class="screen">
          <h2>ğŸ˜µ ä½ å·²ç¶“æ‰ä¸‹å»äº†ï¼</h2>
          <div class="lives-icon">â¤ï¸ â¤ï¸ â¤ï¸</div>
          <p>å‰©é¤˜ç”Ÿå‘½: <strong id="remainingLives">2</strong></p>
          <button class="btn" onclick="continueGame()">ç¹¼çºŒæŒ‘æˆ°</button>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // éŠæˆ²ç‹€æ…‹
      let gameRunning = false;
      let gamePaused = false;
      let score = 0;
      let lives = 3;
      let level = 1;
      const maxLevel = 5;

      // çƒçš„å±¬æ€§
      const ball = {
        x: canvas.width / 2,
        y: canvas.height - 50,
        radius: 10,
        dx: 2.5,
        dy: -2.5,
        speed: 2.5,
        baseSpeed: 2.5,
        launched: false,
      };

      // æ™‚é–“åŠ é€Ÿè¨­å®š
      let gameTime = 0;
      const SPEED_INCREASE_INTERVAL = 500; // æ¯500å¹€å¢åŠ ä¸€æ¬¡é€Ÿåº¦
      const SPEED_INCREASE_AMOUNT = 0.1; // æ¯æ¬¡å¢åŠ çš„é€Ÿåº¦
      const MAX_SPEED_MULTIPLIER = 2.5; // æœ€å¤§é€Ÿåº¦å€ç‡

      // æ“‹æ¿å±¬æ€§
      const paddle = {
        width: 120,
        height: 15,
        x: canvas.width / 2 - 60,
        y: canvas.height - 30,
        speed: 8,
        dx: 0,
      };

      // ç£šå¡Šè¨­å®š
      const brickConfig = {
        rowCount: 5,
        columnCount: 10,
        width: 70,
        height: 25,
        padding: 5,
        offsetTop: 60,
        offsetLeft: 30,
      };

      let bricks = [];

      // åˆå§‹åŒ–ç©ºç£šå¡Šé™£åˆ—çµæ§‹
      function initEmptyBricks() {
        bricks = [];
        for (let c = 0; c < brickConfig.columnCount; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickConfig.rowCount; r++) {
            bricks[c][r] = { status: 0 };
          }
        }
      }
      initEmptyBricks();

      // ç£šå¡Šé¡è‰²ï¼ˆæ ¹æ“šè¡Œæ•¸ï¼‰
      const brickColors = [
        "#ff6b6b", // ç´…
        "#feca57", // é»ƒ
        "#48dbfb", // é’
        "#1dd1a1", // ç¶ 
        "#ff9ff3", // ç²‰
      ];

      // ç²’å­æ•ˆæœ
      let particles = [];

      // å¤šçƒç³»çµ±
      let balls = [];

      // æ‰è½é“å…·
      let powerUps = [];

      // é“å…·é¡å‹
      const POWERUP_TYPES = {
        MULTI_BALL: { color: "#ff6b6b", icon: "âšª", name: "ä¸‰é¡†çƒ" },
        WIDE_PADDLE: { color: "#1dd1a1", icon: "â†”ï¸", name: "æ“‹æ¿åŠ å¯¬" },
        SPEED_UP: { color: "#feca57", icon: "âš¡", name: "åŠ é€Ÿ" },
        SPEED_DOWN: { color: "#48dbfb", icon: "ğŸ¢", name: "æ¸›é€Ÿ" },
      };

      // ç•¶å‰æ•ˆæœç‹€æ…‹ï¼ˆæ¯æ¢å‘½é‡ç½®ï¼‰
      let activeEffects = {
        widePaddle: false,
        speedModifier: 1,
      };

      // é è¨­æ“‹æ¿å¯¬åº¦
      const DEFAULT_PADDLE_WIDTH = 120;

      // åˆå§‹åŒ–ç£šå¡Š
      function initBricks() {
        bricks = [];
        for (let c = 0; c < brickConfig.columnCount; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickConfig.rowCount; r++) {
            // æ ¹æ“šé—œå¡å¢åŠ ç£šå¡Šå¼·åº¦
            let hits = r < level - 1 ? 2 : 1;
            if (level >= 4 && r === 0) hits = 3;

            // éš¨æ©Ÿåˆ†é…é“å…·ï¼ˆç´„ 15% æ©Ÿç‡ï¼‰
            let powerUp = null;
            if (Math.random() < 0.15) {
              const types = Object.keys(POWERUP_TYPES);
              powerUp = types[Math.floor(Math.random() * types.length)];
            }

            bricks[c][r] = {
              x: 0,
              y: 0,
              status: 1,
              hits: hits,
              maxHits: hits,
              color: brickColors[r],
              powerUp: powerUp,
            };
          }
        }
      }

      // å‰µå»ºç²’å­æ•ˆæœ
      function createParticles(x, y, color) {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: x,
            y: y,
            dx: (Math.random() - 0.5) * 8,
            dy: (Math.random() - 0.5) * 8,
            radius: Math.random() * 4 + 2,
            color: color,
            life: 1,
          });
        }
      }

      // æ›´æ–°ç²’å­
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.dx;
          p.y += p.dy;
          p.life -= 0.02;
          p.radius *= 0.98;

          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      // ç¹ªè£½ç²’å­
      function drawParticles() {
        particles.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.fill();
          ctx.globalAlpha = 1;
        });
      }

      // ç¹ªè£½çƒ
      function drawBall() {
        balls.forEach((b) => {
          // ç™¼å…‰æ•ˆæœ
          const gradient = ctx.createRadialGradient(
            b.x,
            b.y,
            0,
            b.x,
            b.y,
            b.radius * 2
          );
          gradient.addColorStop(0, "#fff");
          gradient.addColorStop(0.3, "#e94560");
          gradient.addColorStop(1, "transparent");

          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius * 2, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();

          // çƒæœ¬é«”
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.strokeStyle = "#e94560";
          ctx.lineWidth = 2;
          ctx.stroke();
        });
      }

      // ç¹ªè£½æ“‹æ¿
      function drawPaddle() {
        // ç™¼å…‰æ•ˆæœ
        ctx.shadowColor = "#e94560";
        ctx.shadowBlur = 20;

        // æ“‹æ¿æœ¬é«”
        const gradient = ctx.createLinearGradient(
          paddle.x,
          paddle.y,
          paddle.x,
          paddle.y + paddle.height
        );
        gradient.addColorStop(0, "#e94560");
        gradient.addColorStop(1, "#c73659");

        ctx.beginPath();
        ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.shadowBlur = 0;
      }

      // ç¹ªè£½ç£šå¡Š
      function drawBricks() {
        for (let c = 0; c < brickConfig.columnCount; c++) {
          for (let r = 0; r < brickConfig.rowCount; r++) {
            const brick = bricks[c][r];
            if (brick.status === 1) {
              const brickX =
                c * (brickConfig.width + brickConfig.padding) +
                brickConfig.offsetLeft;
              const brickY =
                r * (brickConfig.height + brickConfig.padding) +
                brickConfig.offsetTop;
              brick.x = brickX;
              brick.y = brickY;

              // æ ¹æ“šå‰©é¤˜è¡€é‡èª¿æ•´é€æ˜åº¦
              const alpha = 0.5 + (brick.hits / brick.maxHits) * 0.5;

              ctx.beginPath();
              ctx.roundRect(
                brickX,
                brickY,
                brickConfig.width,
                brickConfig.height,
                5
              );
              ctx.fillStyle = brick.color;
              ctx.globalAlpha = alpha;
              ctx.fill();
              ctx.globalAlpha = 1;

              // é‚Šæ¡†
              ctx.strokeStyle = "rgba(255,255,255,0.3)";
              ctx.lineWidth = 2;
              ctx.stroke();

              // é¡¯ç¤ºå‰©é¤˜è¡€é‡æˆ–é“å…·åœ–ç¤º
              ctx.fillStyle = "#fff";
              ctx.font = "bold 12px Arial";
              ctx.textAlign = "center";

              if (brick.powerUp) {
                // é¡¯ç¤ºé“å…·åœ–ç¤º
                ctx.font = "14px Arial";
                ctx.fillText(
                  POWERUP_TYPES[brick.powerUp].icon,
                  brickX + brickConfig.width / 2,
                  brickY + brickConfig.height / 2 + 5
                );
              } else if (brick.hits > 1) {
                ctx.fillText(
                  brick.hits,
                  brickX + brickConfig.width / 2,
                  brickY + brickConfig.height / 2 + 4
                );
              }
            }
          }
        }
      }

      // ç¹ªè£½æ‰è½é“å…·
      function drawPowerUps() {
        powerUps.forEach((p) => {
          ctx.beginPath();
          ctx.roundRect(p.x - 15, p.y - 10, 30, 20, 5);
          ctx.fillStyle = POWERUP_TYPES[p.type].color;
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.font = "12px Arial";
          ctx.fillStyle = "#fff";
          ctx.textAlign = "center";
          ctx.fillText(POWERUP_TYPES[p.type].icon, p.x, p.y + 4);
        });
      }

      // æ›´æ–°æ‰è½é“å…·
      function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const p = powerUps[i];
          p.y += 3;

          // æª¢æŸ¥æ˜¯å¦ç¢°åˆ°æ“‹æ¿
          if (
            p.y + 10 >= paddle.y &&
            p.y - 10 <= paddle.y + paddle.height &&
            p.x >= paddle.x &&
            p.x <= paddle.x + paddle.width
          ) {
            activatePowerUp(p.type);
            powerUps.splice(i, 1);
            continue;
          }

          // æ‰å‡ºç•«é¢
          if (p.y > canvas.height) {
            powerUps.splice(i, 1);
          }
        }
      }

      // å•Ÿå‹•é“å…·æ•ˆæœ
      function activatePowerUp(type) {
        switch (type) {
          case "MULTI_BALL":
            // ä¸‰é¡†çƒï¼šç‚ºæ¯å€‹ç¾æœ‰çš„çƒå¢åŠ å…©é¡†
            const newBalls = [];
            balls.forEach((b) => {
              if (b.launched) {
                // å‰µå»ºå…©é¡†æ–°çƒï¼Œè§’åº¦åç§»
                for (let angle of [-0.5, 0.5]) {
                  const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                  const currentAngle = Math.atan2(b.dy, b.dx);
                  newBalls.push({
                    x: b.x,
                    y: b.y,
                    radius: b.radius,
                    dx: speed * Math.cos(currentAngle + angle),
                    dy: speed * Math.sin(currentAngle + angle),
                    speed: b.speed,
                    launched: true,
                  });
                }
              }
            });
            balls = balls.concat(newBalls);
            break;

          case "WIDE_PADDLE":
            // æ“‹æ¿åŠ å¯¬
            if (!activeEffects.widePaddle) {
              activeEffects.widePaddle = true;
              paddle.width = DEFAULT_PADDLE_WIDTH * 1.5;
            }
            break;

          case "SPEED_UP":
            // åŠ é€Ÿ
            activeEffects.speedModifier = 1.3;
            balls.forEach((b) => {
              const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
              const angle = Math.atan2(b.dy, b.dx);
              const newSpeed = b.speed * 1.3;
              b.dx = newSpeed * Math.cos(angle);
              b.dy = newSpeed * Math.sin(angle);
            });
            break;

          case "SPEED_DOWN":
            // æ¸›é€Ÿ
            activeEffects.speedModifier = 0.7;
            balls.forEach((b) => {
              const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
              const angle = Math.atan2(b.dy, b.dx);
              const newSpeed = b.speed * 0.7;
              b.dx = newSpeed * Math.cos(angle);
              b.dy = newSpeed * Math.sin(angle);
            });
            break;
        }

        // é¡¯ç¤ºé“å…·æç¤º
        createPowerUpText(POWERUP_TYPES[type].name);
      }

      // é“å…·æ–‡å­—æç¤º
      let powerUpTexts = [];

      function createPowerUpText(text) {
        powerUpTexts.push({
          text: text,
          y: canvas.height / 2,
          alpha: 1,
        });
      }

      function updatePowerUpTexts() {
        for (let i = powerUpTexts.length - 1; i >= 0; i--) {
          const t = powerUpTexts[i];
          t.y -= 1;
          t.alpha -= 0.02;
          if (t.alpha <= 0) {
            powerUpTexts.splice(i, 1);
          }
        }
      }

      function drawPowerUpTexts() {
        powerUpTexts.forEach((t) => {
          ctx.font = "bold 24px Arial";
          ctx.fillStyle = `rgba(255, 255, 255, ${t.alpha})`;
          ctx.textAlign = "center";
          ctx.fillText(t.text, canvas.width / 2, t.y);
        });
      }

      // é‡ç½®æ•ˆæœï¼ˆæ­»äº¡æ™‚å‘¼å«ï¼‰
      function resetEffects() {
        activeEffects.widePaddle = false;
        activeEffects.speedModifier = 1;
        paddle.width = DEFAULT_PADDLE_WIDTH;
        powerUps = [];
      }
      // ç¢°æ’æª¢æ¸¬ - ä½¿ç”¨åœ“å½¢èˆ‡çŸ©å½¢ç¢°æ’
      function collisionDetection() {
        balls.forEach((ball) => {
          if (!ball.launched) return;

          for (let c = 0; c < brickConfig.columnCount; c++) {
            for (let r = 0; r < brickConfig.rowCount; r++) {
              const brick = bricks[c][r];
              if (brick.status === 1) {
                // æ‰¾å‡ºçƒå¿ƒåˆ°ç£šå¡Šæœ€è¿‘çš„é»
                const closestX = Math.max(
                  brick.x,
                  Math.min(ball.x, brick.x + brickConfig.width)
                );
                const closestY = Math.max(
                  brick.y,
                  Math.min(ball.y, brick.y + brickConfig.height)
                );

                // è¨ˆç®—è·é›¢
                const distX = ball.x - closestX;
                const distY = ball.y - closestY;
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance <= ball.radius) {
                  // åˆ¤æ–·ç¢°æ’æ–¹å‘
                  const ballCenterX = ball.x;
                  const ballCenterY = ball.y;
                  const brickCenterX = brick.x + brickConfig.width / 2;
                  const brickCenterY = brick.y + brickConfig.height / 2;

                  const overlapX =
                    brickConfig.width / 2 +
                    ball.radius -
                    Math.abs(ballCenterX - brickCenterX);
                  const overlapY =
                    brickConfig.height / 2 +
                    ball.radius -
                    Math.abs(ballCenterY - brickCenterY);

                  // æ ¹æ“šé‡ç–Šé‡æ±ºå®šåå½ˆæ–¹å‘
                  if (overlapX < overlapY) {
                    ball.dx = -ball.dx;
                    ball.x += ball.dx > 0 ? overlapX : -overlapX;
                  } else {
                    ball.dy = -ball.dy;
                    ball.y += ball.dy > 0 ? overlapY : -overlapY;
                  }

                  brick.hits--;

                  if (brick.hits <= 0) {
                    brick.status = 0;
                    score += 10 * level;
                    createParticles(
                      brick.x + brickConfig.width / 2,
                      brick.y + brickConfig.height / 2,
                      brick.color
                    );

                    // æ‰è½é“å…·
                    if (brick.powerUp) {
                      powerUps.push({
                        x: brick.x + brickConfig.width / 2,
                        y: brick.y + brickConfig.height / 2,
                        type: brick.powerUp,
                      });
                    }
                  }

                  document.getElementById("score").textContent = score;

                  // æª¢æŸ¥æ˜¯å¦éé—œ
                  if (checkWin()) {
                    if (level < maxLevel) {
                      nextLevel();
                    } else {
                      showWinScreen();
                    }
                  }

                  return;
                }
              }
            }
          }
        });
      }

      // æª¢æŸ¥æ˜¯å¦ç²å‹
      function checkWin() {
        for (let c = 0; c < brickConfig.columnCount; c++) {
          for (let r = 0; r < brickConfig.rowCount; r++) {
            if (bricks[c][r].status === 1) {
              return false;
            }
          }
        }
        return true;
      }

      // ä¸‹ä¸€é—œ
      function nextLevel() {
        level++;
        document.getElementById("level").textContent = level;
        ball.baseSpeed += 0.2;
        ball.speed = ball.baseSpeed;
        resetBall();
        initBricks();
      }

      // é‡ç½®çƒ
      function resetBall() {
        balls = [
          {
            x: paddle.x + paddle.width / 2,
            y: paddle.y - 10 - 5,
            radius: 10,
            dx: ball.speed * (Math.random() > 0.5 ? 1 : -1),
            dy: -ball.speed,
            speed: ball.speed,
            launched: false,
          },
        ];
        // é‡ç½®æ•ˆæœ
        resetEffects();
      }

      // æ›´æ–°éŠæˆ²
      function update() {
        if (!gameRunning || gamePaused) return;

        // æ™‚é–“åŠ é€Ÿæ©Ÿåˆ¶
        gameTime++;
        if (gameTime % SPEED_INCREASE_INTERVAL === 0) {
          const currentMultiplier = ball.speed / ball.baseSpeed;
          if (currentMultiplier < MAX_SPEED_MULTIPLIER) {
            // å¢åŠ åŸºç¤é€Ÿåº¦
            ball.speed += SPEED_INCREASE_AMOUNT;

            // æ›´æ–°æ‰€æœ‰çƒçš„é€Ÿåº¦
            balls.forEach((b) => {
              const currentSpeed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
              const angle = Math.atan2(b.dy, b.dx);
              const newSpeed = currentSpeed + SPEED_INCREASE_AMOUNT;
              b.dx = newSpeed * Math.cos(angle);
              b.dy = newSpeed * Math.sin(angle);
              b.speed = newSpeed;
            });
          }
        }

        // æ ¹æ“šæŒ‰éµç‹€æ…‹ç§»å‹•æ“‹æ¿
        if (keys.left && !keys.right) {
          paddle.dx = -paddle.speed;
        } else if (keys.right && !keys.left) {
          paddle.dx = paddle.speed;
        } else {
          paddle.dx = 0;
        }

        // ç§»å‹•æ“‹æ¿
        paddle.x += paddle.dx;

        // æ“‹æ¿é‚Šç•Œæª¢æ¸¬
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) {
          paddle.x = canvas.width - paddle.width;
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰æœªç™¼å°„çš„çƒ
        const unlaunchedBall = balls.find((b) => !b.launched);
        if (unlaunchedBall) {
          unlaunchedBall.x = paddle.x + paddle.width / 2;
          unlaunchedBall.y = paddle.y - unlaunchedBall.radius - 5;
        }

        // æ›´æ–°æ‰€æœ‰å·²ç™¼å°„çš„çƒ
        for (let i = balls.length - 1; i >= 0; i--) {
          const b = balls[i];
          if (!b.launched) continue;

          // ç§»å‹•çƒ
          b.x += b.dx;
          b.y += b.dy;

          // çƒèˆ‡ç‰†å£ç¢°æ’
          if (b.x - b.radius < 0) {
            b.x = b.radius;
            b.dx = Math.abs(b.dx);
          } else if (b.x + b.radius > canvas.width) {
            b.x = canvas.width - b.radius;
            b.dx = -Math.abs(b.dx);
          }
          if (b.y - b.radius < 0) {
            b.y = b.radius;
            b.dy = Math.abs(b.dy);
          }

          // é˜²æ­¢çƒå®Œå…¨å‚ç›´ç§»å‹•ï¼ˆå¡ä½å•é¡Œï¼‰
          const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
          if (Math.abs(b.dx) < 0.5) {
            b.dx = (b.dx >= 0 ? 1 : -1) * speed * 0.3;
            b.dy =
              (b.dy >= 0 ? 1 : -1) * Math.sqrt(speed * speed - b.dx * b.dx);
          }

          // çƒèˆ‡æ“‹æ¿ç¢°æ’
          if (
            b.y + b.radius > paddle.y &&
            b.y - b.radius < paddle.y + paddle.height &&
            b.x > paddle.x &&
            b.x < paddle.x + paddle.width &&
            b.dy > 0
          ) {
            // æ ¹æ“šæ“Šä¸­ä½ç½®æ”¹è®Šåå½ˆè§’åº¦
            const hitPoint = (b.x - paddle.x) / paddle.width;
            const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);

            // è§’åº¦ç¯„åœå¾ -60 åˆ° 60 åº¦ï¼Œé¿å…å¤ªå‚ç›´
            const angle = (hitPoint - 0.5) * Math.PI * 0.6;

            b.dx = speed * Math.sin(angle);
            b.dy = -Math.abs(speed * Math.cos(angle));

            // ç¢ºä¿æ°´å¹³é€Ÿåº¦ä¸æœƒå¤ªå°
            if (Math.abs(b.dx) < speed * 0.2) {
              b.dx = (b.dx >= 0 ? 1 : -1) * speed * 0.2;
              b.dy = -Math.sqrt(speed * speed - b.dx * b.dx);
            }

            // ç¢ºä¿çƒä¸æœƒå¡åœ¨æ“‹æ¿è£¡
            b.y = paddle.y - b.radius - 1;
          }

          // çƒæ‰è½
          if (b.y + b.radius > canvas.height) {
            balls.splice(i, 1);
          }
        }

        // å¦‚æœæ‰€æœ‰çƒéƒ½æ‰è½äº†
        if (balls.length === 0 || (balls.length === 1 && !balls[0].launched)) {
          if (balls.length === 0) {
            lives--;
            document.getElementById("lives").textContent = lives;

            if (lives <= 0) {
              showGameOver();
            } else {
              showFallScreen();
            }
          }
        }

        // ç¢°æ’æª¢æ¸¬
        collisionDetection();

        // æ›´æ–°ç²’å­
        updateParticles();

        // æ›´æ–°é“å…·
        updatePowerUps();
        updatePowerUpTexts();
      }

      // ç¹ªè£½éŠæˆ²
      function draw() {
        // æ¸…ç©ºç•«å¸ƒ
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç¹ªè£½éŠæˆ²å…ƒç´ 
        drawBricks();
        drawPaddle();
        drawBall();
        drawParticles();
        drawPowerUps();
        drawPowerUpTexts();

        // æš«åœæç¤º
        if (gamePaused) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 48px Arial";
          ctx.textAlign = "center";
          ctx.fillText("æš«åœä¸­", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px Arial";
          ctx.fillText("æŒ‰ P ç¹¼çºŒ", canvas.width / 2, canvas.height / 2 + 40);
        }
      }

      // éŠæˆ²å¾ªç’°
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      // é–‹å§‹éŠæˆ²
      function startGame() {
        hideOverlay("startOverlay");
        gameRunning = true;
        score = 0;
        lives = 3;
        level = 1;
        gameTime = 0;
        ball.speed = ball.baseSpeed;

        document.getElementById("score").textContent = score;
        document.getElementById("lives").textContent = lives;
        document.getElementById("level").textContent = level;

        initBricks();
        resetBall();
      }

      // é‡æ–°é–‹å§‹
      function restartGame() {
        hideOverlay("gameOverOverlay");
        hideOverlay("winOverlay");
        startGame();
      }

      // é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
      function showGameOver() {
        gameRunning = false;
        document.getElementById("finalScore").textContent = score;
        showOverlay("gameOverOverlay");
      }

      // é¡¯ç¤ºç²å‹ç•«é¢
      function showWinScreen() {
        gameRunning = false;
        document.getElementById("winScore").textContent = score;
        showOverlay("winOverlay");
      }

      // é¡¯ç¤ºæ‰è½æç¤ºç•«é¢
      function showFallScreen() {
        gameRunning = false;
        document.getElementById("remainingLives").textContent = lives;

        // å‹•æ…‹é¡¯ç¤ºæ„›å¿ƒ
        const heartsContainer = document.querySelector(".lives-icon");
        let hearts = "";
        for (let i = 0; i < 3; i++) {
          if (i < lives) {
            hearts += "â¤ï¸ ";
          } else {
            hearts += "ğŸ–¤ ";
          }
        }
        heartsContainer.textContent = hearts.trim();

        showOverlay("fallOverlay");
      }

      // ç¹¼çºŒéŠæˆ²
      function continueGame() {
        hideOverlay("fallOverlay");
        gameRunning = true;
        resetBall();
      }

      // é¡¯ç¤º overlay
      function showOverlay(id) {
        const overlay = document.getElementById(id);
        overlay.style.display = "flex";
        // è§¸ç™¼ reflow ä»¥å•Ÿå‹•å‹•ç•«
        overlay.offsetHeight;
        overlay.classList.add("show");
      }

      // éš±è— overlay
      function hideOverlay(id) {
        const overlay = document.getElementById(id);
        overlay.classList.remove("show");
        overlay.style.display = "none";
      }

      // æŒ‰éµç‹€æ…‹
      const keys = {
        left: false,
        right: false,
      };

      // éµç›¤æ§åˆ¶
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") {
          keys.left = true;
        } else if (e.key === "ArrowRight" || e.key === "d") {
          keys.right = true;
        } else if (e.key === " " || e.key === "Enter") {
          // æª¢æŸ¥æ˜¯å¦æœ‰å½ˆçª—é–‹å•Ÿ
          const fallOverlay = document.getElementById("fallOverlay");
          const startOverlay = document.getElementById("startOverlay");
          const gameOverOverlay = document.getElementById("gameOverOverlay");
          const winOverlay = document.getElementById("winOverlay");

          if (
            fallOverlay.classList.contains("show") ||
            fallOverlay.style.display === "flex"
          ) {
            continueGame();
          } else if (
            startOverlay.style.display === "flex" ||
            startOverlay.classList.contains("show")
          ) {
            startGame();
          } else if (
            gameOverOverlay.classList.contains("show") ||
            gameOverOverlay.style.display === "flex"
          ) {
            restartGame();
          } else if (
            winOverlay.classList.contains("show") ||
            winOverlay.style.display === "flex"
          ) {
            restartGame();
          } else if (gameRunning && !gamePaused) {
            // ç™¼å°„æ‰€æœ‰æœªç™¼å°„çš„çƒ
            balls.forEach((b) => {
              if (!b.launched) b.launched = true;
            });
          }
        } else if (e.key === "p" || e.key === "P") {
          if (gameRunning) {
            gamePaused = !gamePaused;
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") {
          keys.left = false;
        } else if (e.key === "ArrowRight" || e.key === "d") {
          keys.right = false;
        }
      });

      // æ»‘é¼ æ§åˆ¶
      canvas.addEventListener("mousemove", (e) => {
        if (!gameRunning || gamePaused) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        paddle.x = mouseX - paddle.width / 2;

        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) {
          paddle.x = canvas.width - paddle.width;
        }
      });

      canvas.addEventListener("click", () => {
        if (gameRunning && !gamePaused) {
          // ç™¼å°„æ‰€æœ‰æœªç™¼å°„çš„çƒ
          balls.forEach((b) => {
            if (!b.launched) b.launched = true;
          });
        }
      });

      // å•Ÿå‹•éŠæˆ²å¾ªç’°
      gameLoop();
    </script>
  </body>
</html>
